import { NginxConfig, ServerConfig, LocationConfig } from '@/types/nginx';

const indent = (level: number) => '    '.repeat(level);

// ============================================================
// 核心工具函数
// ============================================================

/**
 * 将值格式化为 Nginx 配置值
 * - 处理空字符串 -> ""
 * - 处理 undefined/null -> 跳过
 * - 处理需要引号的值
 */
function formatValue(value: string | number | boolean | undefined | null): string | null {
  if (value === undefined || value === null) {
    return null;
  }
  
  if (typeof value === 'boolean') {
    return value ? 'on' : 'off';
  }
  
  if (typeof value === 'number') {
    return String(value);
  }
  
  // 空字符串需要输出 ""
  if (value === '') {
    return '""';
  }
  
  return value;
}

/**
 * 构建单行指令，确保正确的分号管理
 */
function buildDirective(key: string, value: string | number | boolean | undefined | null, indentLevel: number = 0): string | null {
  const formattedValue = formatValue(value);
  if (formattedValue === null) {
    return null;
  }
  
  return `${indent(indentLevel)}${key} ${formattedValue};`;
}

/**
 * 智能清理自定义指令 - 核心去重逻辑
 * 从自定义指令文本中移除已被 UI 管理的指令
 */
export function cleanCustomDirectives(customText: string, activeKeys: string[]): string {
  if (!customText.trim()) {
    return '';
  }
  
  const lines = customText.split('\n');
  const cleanedLines: string[] = [];
  
  for (const line of lines) {
    const trimmed = line.trim();
    
    // 保留空行和注释
    if (!trimmed || trimmed.startsWith('#')) {
      cleanedLines.push(line);
      continue;
    }
    
    // 检查是否与活跃 UI 键冲突
    let isConflict = false;
    for (const key of activeKeys) {
      // 使用正则精确匹配指令名（避免 ssl_protocols 匹配 ssl）
      const regex = new RegExp(`^\\s*${escapeRegex(key)}\\s+`, 'i');
      if (regex.test(trimmed)) {
        isConflict = true;
        break;
      }
    }
    
    if (!isConflict) {
      cleanedLines.push(line);
    }
  }
  
  // 移除连续的空行
  return cleanedLines
    .join('\n')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

/**
 * 转义正则特殊字符
 */
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * 确保每行以分号结尾（如果需要的话）
 */
function ensureSemicolons(text: string): string {
  if (!text.trim()) return '';
  
  return text
    .split('\n')
    .map(line => {
      const trimmed = line.trim();
      // 空行、注释、块开始/结束不需要分号
      if (!trimmed || trimmed.startsWith('#') || trimmed.endsWith('{') || trimmed === '}') {
        return line;
      }
      // 已有分号
      if (trimmed.endsWith(';')) {
        return line;
      }
      // 添加分号
      return line + ';';
    })
    .join('\n');
}

/**
 * 检测 Server 是否为跳转服务（Redirect Server）
 * 跳转服务不需要 root/index/try_files 和复杂安全头
 */
export function isRedirectServer(server: ServerConfig): boolean {
  // 检查自定义指令是否包含 return 301/302/307/308
  const redirectPattern = /^\s*return\s+(301|302|307|308)\s+/m;
  return redirectPattern.test(server.customDirectives);
}

/**
 * 检测 Location 是否为跳转 Location
 */
export function isRedirectLocation(location: LocationConfig): boolean {
  // 有 returnCode 且是跳转码
  if (location.returnCode && [301, 302, 307, 308].includes(location.returnCode)) {
    return true;
  }
  // 自定义指令包含跳转
  const redirectPattern = /^\s*return\s+(301|302|307|308)\s+/m;
  return redirectPattern.test(location.customDirectives);
}

// ============================================================
// 主生成器函数
// ============================================================

export const generateNginxConfig = (config: NginxConfig): string => {
  // If raw config exists (imported), return it directly without modifications
  if (config.rawConfig) {
    return config.rawConfig;
  }
  
  const lines: string[] = [];
  
  // Header comment
  lines.push('# Generated by Nginx Config Master');
  lines.push('# https://nginx-config-master.lovable.app');
  lines.push('');
  
  // ==================== Global Context ====================
  const globalActiveKeys = ['user', 'worker_processes', 'error_log', 'pid'];
  
  lines.push(`user ${config.global.user};`);
  lines.push(`worker_processes ${config.global.workerProcesses};`);
  lines.push(`error_log ${config.global.errorLog.path} ${config.global.errorLog.level};`);
  lines.push(`pid ${config.global.pid};`);
  
  const cleanedGlobalDirectives = cleanCustomDirectives(config.global.customDirectives, globalActiveKeys);
  if (cleanedGlobalDirectives) {
    lines.push('');
    lines.push('# Custom global directives');
    lines.push(ensureSemicolons(cleanedGlobalDirectives));
  }
  
  lines.push('');
  
  // ==================== Events Context ====================
  const eventsActiveKeys = ['worker_connections', 'use', 'multi_accept'];
  
  lines.push('events {');
  lines.push(`${indent(1)}worker_connections ${config.events.workerConnections};`);
  lines.push(`${indent(1)}use ${config.events.use};`);
  if (config.events.multiAccept) {
    lines.push(`${indent(1)}multi_accept on;`);
  }
  
  const cleanedEventsDirectives = cleanCustomDirectives(config.events.customDirectives, eventsActiveKeys);
  if (cleanedEventsDirectives) {
    lines.push('');
    lines.push(`${indent(1)}# Custom events directives`);
    cleanedEventsDirectives.split('\n').forEach(line => {
      if (line.trim()) lines.push(`${indent(1)}${ensureSemicolons(line)}`);
    });
  }
  lines.push('}');
  lines.push('');
  
  // ==================== HTTP Context ====================
  const httpActiveKeys = [
    'include', 'default_type', 'log_format', 'access_log',
    'sendfile', 'tcp_nopush', 'tcp_nodelay', 'keepalive_timeout', 'types_hash_max_size',
    'server_tokens', 'client_max_body_size',
    'gzip', 'gzip_comp_level', 'gzip_min_length', 'gzip_types'
  ];
  
  lines.push('http {');
  
  // MIME types
  if (config.http.includeMimeTypes) {
    lines.push(`${indent(1)}include /etc/nginx/mime.types;`);
  }
  lines.push(`${indent(1)}default_type ${config.http.defaultType};`);
  lines.push('');
  
  // Logging
  lines.push(`${indent(1)}log_format ${config.http.logFormat.name} '${config.http.logFormat.format}';`);
  lines.push(`${indent(1)}access_log ${config.http.accessLog.path} ${config.http.accessLog.format};`);
  lines.push('');
  
  // Basic settings
  lines.push(`${indent(1)}sendfile ${config.http.sendfile ? 'on' : 'off'};`);
  lines.push(`${indent(1)}tcp_nopush ${config.http.tcpNopush ? 'on' : 'off'};`);
  lines.push(`${indent(1)}tcp_nodelay ${config.http.tcpNodelay ? 'on' : 'off'};`);
  lines.push(`${indent(1)}keepalive_timeout ${config.http.keepaliveTimeout};`);
  lines.push(`${indent(1)}types_hash_max_size ${config.http.typesHashMaxSize};`);
  lines.push('');
  
  // Security
  lines.push(`${indent(1)}server_tokens ${config.http.serverTokens ? 'on' : 'off'};`);
  lines.push(`${indent(1)}client_max_body_size ${config.http.clientMaxBodySize};`);
  lines.push('');
  
  // Gzip
  if (config.http.gzip.enabled) {
    lines.push(`${indent(1)}# Gzip Settings`);
    lines.push(`${indent(1)}gzip on;`);
    lines.push(`${indent(1)}gzip_comp_level ${config.http.gzip.compLevel};`);
    lines.push(`${indent(1)}gzip_min_length ${config.http.gzip.minLength};`);
    lines.push(`${indent(1)}gzip_types ${config.http.gzip.types.join(' ')};`);
    lines.push('');
  }
  
  const cleanedHttpDirectives = cleanCustomDirectives(config.http.customDirectives, httpActiveKeys);
  if (cleanedHttpDirectives) {
    lines.push(`${indent(1)}# Custom HTTP directives`);
    cleanedHttpDirectives.split('\n').forEach(line => {
      if (line.trim()) lines.push(`${indent(1)}${ensureSemicolons(line)}`);
    });
    lines.push('');
  }
  
  // ==================== Upstreams ====================
  config.upstreams.forEach(upstream => {
    const upstreamActiveKeys = ['least_conn', 'ip_hash', 'server'];
    
    lines.push(`${indent(1)}# Upstream: ${upstream.name}`);
    lines.push(`${indent(1)}upstream ${upstream.name} {`);
    
    if (upstream.strategy === 'least_conn') {
      lines.push(`${indent(2)}least_conn;`);
    } else if (upstream.strategy === 'ip_hash') {
      lines.push(`${indent(2)}ip_hash;`);
    }
    
    upstream.servers.forEach(server => {
      let serverLine = `${indent(2)}server ${server.address}:${server.port}`;
      if (server.weight !== 1) serverLine += ` weight=${server.weight}`;
      if (server.maxFails !== 1) serverLine += ` max_fails=${server.maxFails}`;
      if (server.failTimeout !== 10) serverLine += ` fail_timeout=${server.failTimeout}s`;
      if (server.backup) serverLine += ' backup';
      if (server.down) serverLine += ' down';
      serverLine += ';';
      lines.push(serverLine);
    });
    
    const cleanedUpstreamDirectives = cleanCustomDirectives(upstream.customDirectives, upstreamActiveKeys);
    if (cleanedUpstreamDirectives) {
      lines.push('');
      cleanedUpstreamDirectives.split('\n').forEach(line => {
        if (line.trim()) lines.push(`${indent(2)}${ensureSemicolons(line)}`);
      });
    }
    
    lines.push(`${indent(1)}}`);
    lines.push('');
  });
  
  // ==================== Servers ====================
  config.servers.forEach(server => {
    const serverLocations = config.locations.filter(l => l.serverId === server.id);
    const serverIsRedirect = isRedirectServer(server);
    
    const serverActiveKeys = [
      'listen', 'server_name', 'root', 'index',
      'ssl_certificate', 'ssl_certificate_key', 'ssl_protocols', 'ssl_ciphers', 'ssl_prefer_server_ciphers'
    ];
    
    // HTTPS redirect server block (auto-generated, not from custom directives)
    if (server.ssl.enabled && server.ssl.forceRedirect) {
      lines.push(`${indent(1)}# HTTP to HTTPS redirect for ${server.serverName}`);
      lines.push(`${indent(1)}server {`);
      lines.push(`${indent(2)}listen 80;`);
      lines.push(`${indent(2)}server_name ${server.serverName};`);
      lines.push(`${indent(2)}return 301 https://$server_name$request_uri;`);
      lines.push(`${indent(1)}}`);
      lines.push('');
    }
    
    lines.push(`${indent(1)}# Server: ${server.name}`);
    lines.push(`${indent(1)}server {`);
    
    // Listen directive
    let listenLine = `${indent(2)}listen ${server.listen.port}`;
    if (server.ssl.enabled) listenLine += ' ssl';
    if (server.listen.http2) listenLine += ' http2';
    if (server.listen.defaultServer) listenLine += ' default_server';
    listenLine += ';';
    lines.push(listenLine);
    
    lines.push(`${indent(2)}server_name ${server.serverName};`);
    lines.push('');
    
    // SSL configuration
    if (server.ssl.enabled) {
      lines.push(`${indent(2)}# SSL Configuration`);
      lines.push(`${indent(2)}ssl_certificate ${server.ssl.certificate};`);
      lines.push(`${indent(2)}ssl_certificate_key ${server.ssl.certificateKey};`);
      lines.push(`${indent(2)}ssl_protocols ${server.ssl.protocols.join(' ')};`);
      lines.push(`${indent(2)}ssl_ciphers '${server.ssl.ciphers}';`);
      lines.push(`${indent(2)}ssl_prefer_server_ciphers on;`);
      lines.push('');
    }
    
    // Root and index - 仅非跳转服务器需要
    if (!serverIsRedirect) {
      if (server.root) {
        lines.push(`${indent(2)}root ${server.root};`);
      }
      if (server.index.length > 0) {
        lines.push(`${indent(2)}index ${server.index.join(' ')};`);
      }
      lines.push('');
    }
    
    const cleanedServerDirectives = cleanCustomDirectives(server.customDirectives, serverActiveKeys);
    if (cleanedServerDirectives) {
      lines.push(`${indent(2)}# Custom server directives`);
      cleanedServerDirectives.split('\n').forEach(line => {
        if (line.trim()) lines.push(`${indent(2)}${ensureSemicolons(line)}`);
      });
      lines.push('');
    }
    
    // ==================== Locations ====================
    serverLocations.forEach(location => {
      const locationIsRedirect = isRedirectLocation(location);
      
      const locationActiveKeys = [
        'proxy_pass', 'proxy_http_version', 'proxy_set_header',
        'alias', 'try_files', 'return', 'rewrite',
        'allow', 'deny', 'auth_basic', 'auth_basic_user_file',
        'add_header'
      ];
      
      const modifier = location.modifier ? `${location.modifier} ` : '';
      lines.push(`${indent(2)}location ${modifier}${location.path} {`);
      
      // Proxy pass - 仅非跳转 Location 需要
      if (!locationIsRedirect && (location.proxyPass || location.upstreamId)) {
        const upstream = location.upstreamId 
          ? config.upstreams.find(u => u.id === location.upstreamId)
          : null;
        const proxyTarget = upstream ? `http://${upstream.name}` : location.proxyPass;
        
        if (proxyTarget) {
          // WebSocket support
          if (location.websocket) {
            lines.push(`${indent(3)}proxy_http_version 1.1;`);
          }
          
          lines.push(`${indent(3)}proxy_pass ${proxyTarget};`);
          
          // Headers
          location.headers.filter(h => h.enabled).forEach(header => {
            // 确保空值输出 ""
            const headerValue = header.value === '' ? '""' : header.value;
            lines.push(`${indent(3)}proxy_set_header ${header.name} ${headerValue};`);
          });
          
          // WebSocket headers
          if (location.websocket) {
            lines.push(`${indent(3)}proxy_set_header Upgrade $http_upgrade;`);
            lines.push(`${indent(3)}proxy_set_header Connection "upgrade";`);
          }
          
          lines.push('');
        }
      }
      
      // CORS - 仅非跳转 Location 需要
      if (!locationIsRedirect && location.cors.enabled) {
        lines.push(`${indent(3)}# CORS Configuration`);
        lines.push(`${indent(3)}add_header 'Access-Control-Allow-Origin' '${location.cors.allowOrigin || '*'}';`);
        lines.push(`${indent(3)}add_header 'Access-Control-Allow-Methods' '${location.cors.allowMethods.join(', ')}';`);
        lines.push(`${indent(3)}add_header 'Access-Control-Allow-Headers' '${location.cors.allowHeaders.join(', ')}';`);
        if (location.cors.allowCredentials) {
          lines.push(`${indent(3)}add_header 'Access-Control-Allow-Credentials' 'true';`);
        }
        lines.push('');
      }
      
      // Static file settings - 仅非跳转 Location 需要 alias/try_files
      if (!locationIsRedirect) {
        if (location.alias) {
          lines.push(`${indent(3)}alias ${location.alias};`);
        }
        if (location.tryFiles) {
          lines.push(`${indent(3)}try_files ${location.tryFiles};`);
        }
      }
      
      // Return/Rewrite - 始终需要
      if (location.returnCode && location.returnUrl) {
        lines.push(`${indent(3)}return ${location.returnCode} ${location.returnUrl};`);
      } else if (location.returnCode && !location.returnUrl) {
        // 无 URL 的 return（如 return 403;）
        lines.push(`${indent(3)}return ${location.returnCode};`);
      }
      
      if (location.rewrite) {
        lines.push(`${indent(3)}rewrite ${location.rewrite.pattern} ${location.rewrite.replacement} ${location.rewrite.flag};`);
      }
      
      // Access control
      location.accessControl.allow.forEach(ip => {
        lines.push(`${indent(3)}allow ${ip};`);
      });
      location.accessControl.deny.forEach(ip => {
        lines.push(`${indent(3)}deny ${ip};`);
      });
      
      if (location.accessControl.authBasic.enabled) {
        lines.push(`${indent(3)}auth_basic "${location.accessControl.authBasic.realm}";`);
        lines.push(`${indent(3)}auth_basic_user_file ${location.accessControl.authBasic.userFile};`);
      }
      
      const cleanedLocationDirectives = cleanCustomDirectives(location.customDirectives, locationActiveKeys);
      if (cleanedLocationDirectives) {
        lines.push('');
        lines.push(`${indent(3)}# Custom location directives`);
        cleanedLocationDirectives.split('\n').forEach(line => {
          if (line.trim()) lines.push(`${indent(3)}${ensureSemicolons(line)}`);
        });
      }
      
      lines.push(`${indent(2)}}`);
      lines.push('');
    });
    
    lines.push(`${indent(1)}}`);
    lines.push('');
  });
  
  lines.push('}');
  
  return lines.join('\n');
};
